#!/usr/bin/env python3

###############################################################################
#
#  TestGenerator
#
#  A tool to run a series of pre-definded 'test tasks'. 
#  The tool is a general framework, basically an engine to run the custom 
#    defined test tasks
#
#  Generator
#      Process each FeatureTask in TaskList. [repeat=?].       (Feature defined in FeatureSet)
#          Process each FunctionTask(scenario) for current feature. [repeat=?]  (function/Scenario defined in FeatureSet.Function)
#              Generate a set of data for current scenario
#
#  The 'test tasks' could be Feature or Function -- 2 levels of objects as  
#    defined in class Task and its derived subClasses FeatureTask/FunctionTask
#    and be inputted from a tasklist to the Generator to process
#  Feature1 { Function1, Function2, ... }
#  Feature2 { Function1, Function2, ... }
#
#  [Usage]:
#  1. Regist feature set to generator.   (call RegistFeatureSet)
#  2. Prepare tasklist (feature/functions to test) and import it to generator.  (call Generator::ImportTasksFromNamelist)
#  3. 
#
# Author: Jerry Xie
# Date:   May 2016
#
###############################################################################

from common import *

'''
from __future__ import print_function

import sys
import os
import platform


from shutil import copyfile

# For pythen 2 and 3 compatibility
try:
        from urllib.request import urlopen, URLopener
        from urllib.parse import urlparse
except ImportError:
        from urllib import urlopen, URLopener
        from urlparse import urlparse

try:
        from http.client import HTTPConnection, HTTPResponse, HTTPException, IncompleteRead
except ImportError:
        from httplib import HTTPConnection, HTTPResponse, HTTPException, IncompleteRead

try:
        from subprocess import getstatusoutput, getoutput, Popen, PIPE, STDOUT
except:
        from commands import getstatusoutput, getoutput 
        from os import popen

# WebSocket lib
try:
        from ws4py.websocket import WebSocket
        from ws4py.client.threadedclient import WebSocketClient
except ImportError:
        sys.path.append(ws4py_path)
        from ws4py.websocket import WebSocket
        from ws4py.client.threadedclient import WebSocketClient

# for platform compatiblity
if platform.system().lower() == 'windows':
        #ws4py_path = "C:\\DEV\\Python\\pkgs\\WebSocket-for-Python-master\\ws4py"
        PATHSPLITER="\\"
else:
        #ws4py_path="\/usr\/local\/lib\/python2.7\/dist-packages\/ws4py"
        PATHSPLITER="/"

dbgFlag = True
def TRACE(str):
    if dbgFlag:
        print(str)
'''

#########################################################################
# Test Data Generator
# -- To generate test data for a set of Feature-Scenario
#  
'''
  Generator
      Process each feature in TaskQueue. [repeat=?].       (Feature defined in FeatureSet)
          Process each function/scenario for current feature. [repeat=?]  (function/Scenario defined in FeatureSet.Function)
              Generate a set of data for current scenario
'''


FeatureSet = {  # "Feature1":{ "Function11", "Function12", ...}
                # "Feature2":{ "Function21", "Function22", ...}
             }
FeatureName = set()    #{ # "feature1", "feature2", ... ''' }           # Will be automatically initialized by RegistFeatureSet per FeatureSet input
TestHandlerName = set() #{ }                                            # Will be automatically generated by RegistFeatureSet per FeatureSet input
    # "Feature1":{ "Function1":"Feature1_Functin1_Handler", 
    #              "Function2":"Feature1_Function2_Handler", ...}
TestHandlerSet = {}                                                    # { Feature1:{Func11:Handler11, Func12:Handler12} }, ...}
TestHandlerDict = {}                                                   # { "HandlerName":Handler, ... }

#########################################################################

# Regist feature set to testgen
# Feature set is inform of dictionary
# e.g.   featureset = { "feature1":{ "func11", "func12" },  "feature2":{ "func21", "func22" }, }
def RegistFeatureSet(featureset):
    FeatureSet.update(featureset)
    for featr in featureset.keys():            # feature_x
        FeatureName.add(featr)

        funcDict = {}
        for func in featureset[featr]:          # function_x
            handlr = GetTestHanderName(featr,func)        #featr+'_'+func+'_'+'Handler'
            TestHandlerName.add(handlr)
            #TestHandlerDict.update({handlr:handlr})

            k2=func
            v2=handlr
            funcDict.update([(k2,v2)])

        k1 = featr
        v1 = funcDict
        TestHandlerSet.update([(k1, v1)])

    TRACE("[RegistFeatureSet] FeatureSet: %s" % (FeatureSet))
    TRACE("[RegistFeatureSet] FeatureName: %s" % (FeatureName))
    TRACE("[RegistFeatureSet] TestHandlerName: %s" % (TestHandlerName))
    TRACE("[RegistFeatureSet] TestHandlerSet: %s" % (TestHandlerSet))

def RegistHandlerDict(handlerDict):
    global TestHandlerDict
    TestHandlerDict.update(handlerDict)

def GetTestHanderName(feature, function):
    str = feature+'_'+function+'_'+'Handler'
    return str

class Task():
    TASKTYPE = ( "FEATURE", "FUNCTION" )
    _Type = None
    TaskFeature = None          # Feature name for the task. if the task type is feature, it is just the feature name.
    Task = None                 # The real task object, if task type is 'Feature', this is the function set of a feature ()
                                #                       if task type is 'Function', this is the function of the a feature (TaskName)
    _objSubTypes = set()

    def __init__(self, tasktype, taskname, upperlevel=None):
        if tasktype not in self.TASKTYPE:
            raise ValueError("Invalide tasktype %s" % (tasktype))
        self._Type = tasktype
        self._objSubTypes.add(self.__class__.__name__)
        #TRACE("Task._objSubType added: %s" % (self.__class__.__name__))

    @property
    def Type(self):
        return self._Type
    @Type.getter
    def Type(self):
        return self._Type
    @Type.setter
    def Type(self, type):
        if type not in self.TASKTYPE:
            TRACE("Invalide type parameter -- %s" % (type))
        self._Type = type

class FeatureTask(Task):
    #Feature = None
    def __init__(self, taskname):
        Task.__init__(self, "FEATURE", taskname)
        if self.Type != "FEATURE":
            raise ValueError("Invalid type. Should be %s but actually %s" % ("FEATURE", self.Type))       
        if taskname not in FeatureSet:
            raise ValueError("Invalide Feature -- %s not in FeatureSet" % (taskname))

        self.TaskFeature = taskname
        self.Task = FeatureSet[taskname]
        #TRACE("[FeatureTask::__init__]: %s.Task initialized as %s.%s" % (self, self.TaskFeature, self.Task))
        

class FunctionTask(Task):
    #Function = None
    def __init__(self, functionname, featurename):
        Task.__init__(self, "FUNCTION", functionname, featurename)
        if self.Type != "FUNCTION":
            raise ValueError("Invalid type. Should be %s but actually %s" % ("FUNCTION", self.Type))
        if functionname not in FeatureSet[featurename]:
            raise ValueError("Invalide function -- %s[%s] not in FeatureSet" % (featurename[functionname]))
        self.TaskFeature = featurename
        self.Task = functionname
        #TRACE("[FeatureTask::__init__]: %s.Task initialized as %s.%s" % (self, self.TaskFeature, self.Task))


class Generator():
    # property
    WORKMODE     = ("RUNONCE", "LOOP")

    _WorkMode    = "RUNONCE"               # use property WorkMode to access
    _TaskList    = []                      # Task list
    _Engine      = None                    # embedded obj Engine
    _TaskManager = None                    # embedded obj TaskManager

    def __init__(self):
        self._Engine = Generator.Engine(self)
        self._TaskManager = Generator.TaskManager(self)

    @property
    def WorkMode(self):
        return self._WorkMode
    @WorkMode.getter
    def WorkMode(self):
        return self._WorkMode
    @WorkMode.setter
    def WorkMode(self, mode):
        if mode not in Generator.WORKMODE:
            return False
        self._WorkMode = mode
        return True

    def ImportTasks(self, tsklist):
        return self._TaskManager.ImportTasks(tsklist)

    def ImportTasksFromNamelist(self, tsklist):
        return self._TaskManager.ImportTasksFromNamelist(tsklist)

    def Run(self):
        TRACE("[Generator.Run]: ")
        return self._Engine.Start()

    class TaskManager():
        _Parent   = None
        _TaskIter = None

        def __init__(self, parent):
            if parent == None:
                raise ValueError("Invalide input parameter 'parent' as %s" % (parent))
            self._Parent   = parent
            self._TaskIter = iter(self._Parent._TaskList)

        # To import tasks from a task object list.  
        # The list contain FeatureTask objects or FunctionTask object, or a mixture
        # The inputted objects will be added to internal TaskList directly since they are already 'Task' objects.
        def ImportTasks(self, list):
            self._Parent._TaskList.clear()
            count = 0
            for tsk in list:
                tskType = tsk.__class__.__name__
                #TRACE("[Generator::ImportTask]: tskType is %s" % (tskType))

                if tskType in Task._objSubTypes:
                    self._Parent._TaskList.append(tsk)
                    count += 1
                    TRACE("Import %s into TaskList: + %s.%s" % (tskType, tsk.TaskFeature, tsk.Task))
                else:
                    TRACE("Invalid task type bypassed (%s)" % (tskType))
            return count;

        # To import tasks from a name list containing feature-name and|or function name.   
        # The inputted names will be checked and if they match the feature/function names in 'FeatureSet', 
        #   the corresponding FeatureTask or FunctionTask objects will be created and added to internal TaskList.
        # The inputted Naming rule for Feature and Function objects:
        #   Feature:  "featurename",  e.g  "CellScan"
        #   Function: "feature-name.functionname",  e.g  "CellScan.CellIdDisplay"
        def ImportTasksFromNamelist(self, list):
            self._Parent._TaskList.clear()
            count = 0
            featureCount = 0
            functionCount = 0
            for nm in list:
                #TRACE("nm = %s" % (nm))
                if nm in FeatureSet.keys():                                      # feature name found
                    tsk = FeatureTask(nm)
                    tskType = tsk.__class__.__name__
                    self._Parent._TaskList.append(tsk)
                    count += 1
                    featureCount += 1
                    TRACE("Import %s into TaskList: + %s" % (tskType, tsk.Task))
                elif (nm.find('.') != -1):
                    (feature, sep, func) = nm.partition('.')
                    if (feature in FeatureSet) and (func in FeatureSet[feature]):        # function name found
                        tsk = FunctionTask(func, feature)
                        tskType = tsk.__class__.__name__
                        self._Parent._TaskList.append(tsk)
                        count += 1
                        functionCount += 1
                        #TRACE("Import %s into TaskList: + %s, %s" % (tskType, tsk.TaskFeature, tsk.Task))
                    else:
                        TRACE("Can't find function %s in FeatureSet" % (nm))
                else:
                    TRACE("Invalid task bypassed (%s) -- Cannot find it in FeatureSet" % (nm))

            TRACE("[ImportTaskFromNamelist]: %d tasks imported. (%d Features, %d Functions)" % (count,featureCount, functionCount))
            return count;
        '''
        # Add a feature into the taskList from the FeatureSet
        def AddFeatureTask(self, featureName):
            # not implemented
            return True

        # Add a feature::function into the taskList from the FeatureSet
        def AddFunctionTask(self, featureName, functionName):
            # not implemented
            return True
        '''
        def PickTask(self):
            try:
                tsk = next(self._TaskIter)
            except StopIteration as e:
                tsk = None
            if tsk != None:
                TRACE("[Generator::_TaskManager::PickTask]: %s.%s" % (tsk.TaskFeature, tsk.Task))
            return tsk

        def DelTask(self, tsk):
            self._Parent._TaskList.remove(tsk)
            TRACE("[Generator::TaskManager:DelTask]: Task removed from list -- %s.%s" % (tsk.TaskFeature, tsk.Task))
            return False

        def ResetTask(self):
            self._TaskIter = iter(self._Parent._TaskList)
            return True

    # =================================================================================
    # Generator::Engine -- to process the tasks in Generator::_TaskList
    #     The Engine grab tasks from the internal task list one by one until the TaskList is empty
    #     If the task is a FunctionTask, it is processed directly
    #     If the task is a FeatureTask, the engine will iterate all the functions under the feature
    # EngineStatus:   STOP     -- Will not process tasks even if the taskList is not empty
    #                 RUN      -- Processing tasks in tasklist
    #                 IDLE     -- Engine enabled, but not tasks to process in tasklist so far. 
    #                             Once there are tasks found in list, it will switch to 'RUN'
    class Engine():
        ENGINE_STATUS = ( "STOP", "RUN", "IDLE" )
        _Status = "STOP"
        _Parent = None
        
        def __init__(self, parent):
            TRACE("[Generator::Engine] Init")
            self._Status = "STOP"
            self._Parent = parent

        @property
        def Status(self):
            return self._Status
        @Status.getter
        def Status(self):
            return self._Status
        @Status.setter
        def Status(self, stat):
            if stat in self.ENGINE_STATUS:
                self._Status = stat
            return self._Status

        def Start(self):
            if self.Status != "STOP":
                return True
            self.Status = "IDLE"
            self.Process()
            return True

        def Stop(self):
            self.Status = "STOP"
            TRACE("[Generator::Engine::Stop]")
            return True
        
        # The main process entry of the Engine
        # Process the tasks once or recursive per WorkMode
        def Process(self):
            if self.Status == "STOP":
                TRACE("[Generator::Engine::Process] Fail to process. Engine not started yet.")
                return False

            i = 0
            while (self.Status != "STOP"):
                i += 1
                TRACE("[Generator::Engine::Process] round# %d" % (i))
                self._Process()                   # Process through the tasklist

                wkmode = self._Parent.WorkMode
                if wkmode == "RUNONCE":           # Stop the engine
                    self.Stop()
                    break
                elif wkmode == "LOOP":            # No stop, keep IDLE
                    self.Status = "IDLE"
                    self._Parent._TaskManager.ResetTask()            
                else:
                    TRACE("[Generator::Engine::_Process] Invalid WorkMode %s" % (self._Parent.WorkMode))

                if (dbgFlag):
                    if i >= 3:
                        break


        # Process the TaskList for one round
        def _Process(self):
            if self.Status == "STOP":
                TRACE("[Generator::Engine::_Process] Fail to process. Engine not started yet.")
                return False

            while True:
                # Check TaskList
                tsk = self._Parent._TaskManager.PickTask()
                if tsk == None:                                # No tasks to process (TaskList is empty)
                    break
                else:      # Process task
                    self.Status = "RUN"
                    ret = self._ProcessTask(tsk)
                #if dbgFlag:
                #    PrintGeneratorTaskList(self._Parent)
                continue

            return True

        # Process one single task
        def _ProcessTask(self, tsk):
            TRACE("[Generator::Engine::_ProcessTask]: %s.%s" % (tsk.TaskFeature, tsk.Task))
            if tsk == None:
                return True
            # process
            if tsk.Type == "FEATURE":       # iterate & run all the feature functions handler
                featureName = tsk.TaskFeature
                for func in tsk.Task:
                    hdlrName = GetTestHanderName(featureName, func)
                    TRACE("Call %s" % (hdlrName))
                    hdlr = TestHandlerDict[hdlrName]
                    hdlr()
            else:
                hdlrName = GetTestHanderName(tsk.TaskFeature, tsk.Task)
                TRACE("Call %s" % (hdlrName))
                hdlr = TestHandlerDict[hdlrName]
                hdlr()
            return True




'''
if platform.system().lower() == 'windows':
        FwLocalDirRoot = "C:\\test\\FW"
else:
        FwLocalDirRoot = "/tmp/FW"                # may encounter permission deney err on linux if use dir like /test/FW
'''

#########################################################################

def RemoteAdbCmd(cmdStr):
    cmd = "adb shell " + cmdStr

    status, output = getstatusoutput(cmd)
    print(output, end="")

    return status




def RunSimulation():
    TRACE("[RunSimulation]: ")
    
    RemoteAdbCmd("rdb dump ttest")        


#######################################################################        

def PrintGeneratorTaskList(gen):
    print("Generator::_Tasklist:")
    i = 1
    for tsk in gen._TaskList:
        print("  %d) %s:%s" % (i, tsk.TaskFeature, tsk.Task))
        i += 1
        
#######################################################################        




    
    
